; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Custom_Init||, CODE, READONLY, ALIGN=2

                  Custom_Init PROC
;;;352    
;;;353    void Custom_Init(void)
000000  b510              PUSH     {r4,lr}
;;;354    {	
;;;355    	//EVM LED
;;;356    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c0c              LDR      r4,|L1.52|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;357    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;358    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  2201              MOVS     r2,#1
00001a  2104              MOVS     r1,#4
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetMode
;;;359    
;;;360    	//EVM button
;;;361    	GPIO_SetMode(PG,BIT15,GPIO_MODE_INPUT);	
000022  13e1              ASRS     r1,r4,#15
000024  4803              LDR      r0,|L1.52|
000026  2200              MOVS     r2,#0
000028  e8bd4010          POP      {r4,lr}
00002c  3840              SUBS     r0,r0,#0x40
00002e  f7ffbffe          B.W      GPIO_SetMode
;;;362    	
;;;363    }
;;;364    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.QEI0_Init||, CODE, READONLY, ALIGN=2

                  QEI0_Init PROC
;;;202    
;;;203    void QEI0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;204    {
;;;205    	QEI_Open(QEI0, QEI_CTL_X4_FREE_COUNTING_MODE, 0xFFFF);
000002  4c06              LDR      r4,|L3.28|
000004  f64f72ff          MOV      r2,#0xffff
000008  2100              MOVS     r1,#0
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       QEI_Open
;;;206    
;;;207        QEI_Start(QEI0);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      QEI_Start
;;;208    }
;;;209    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x400b0000

                          AREA ||i.QEI0_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  QEI0_Process PROC
;;;178    
;;;179    void QEI0_Process(void)
000000  b530              PUSH     {r4,r5,lr}
;;;180    {
;;;181    	/*
;;;182    		DOWN_COUNT : 0
;;;183    		UP_COUNT : 1
;;;184    	*/
;;;185    	char str[32];
;;;186    	uint8_t dir = QEI_GET_DIR(QEI0);
000002  4815              LDR      r0,|L4.88|
000004  b08b              SUB      sp,sp,#0x2c           ;180
000006  6ac1              LDR      r1,[r0,#0x2c]
;;;187    	uint16_t value = QEI_GET_CNT_VALUE(QEI0);
000008  6800              LDR      r0,[r0,#0]
00000a  f3c12500          UBFX     r5,r1,#8,#1           ;186
00000e  b284              UXTH     r4,r0
;;;188    
;;;189    	if (is_flag_set(flag_UART_PDMA))
000010  4812              LDR      r0,|L4.92|
000012  6841              LDR      r1,[r0,#4]  ; BitFlag
000014  0709              LSLS     r1,r1,#28
000016  d51d              BPL      |L4.84|
;;;190    	{
;;;191    		set_flag(flag_UART_PDMA , DISABLE);
000018  6841              LDR      r1,[r0,#4]  ; BitFlag
00001a  f0210108          BIC      r1,r1,#8
00001e  6041              STR      r1,[r0,#4]  ; BitFlag
;;;192    
;;;193    		sprintf(str, "Encoder:%d", value);
000020  4622              MOV      r2,r4
000022  a10f              ADR      r1,|L4.96|
000024  a803              ADD      r0,sp,#0xc
000026  f7fffffe          BL       __2sprintf
;;;194    
;;;195    		UART_TX_PDMA((uint8_t*)str,strlen(str));
00002a  a803              ADD      r0,sp,#0xc
00002c  f7fffffe          BL       strlen
000030  b281              UXTH     r1,r0
000032  a803              ADD      r0,sp,#0xc
000034  f7fffffe          BL       UART_TX_PDMA
;;;196    		
;;;197    		#if (_debug_log_UART_ == 1)	//debug
;;;198    	    printf("%s : %5d , 0x%2X (%s , %2d , %2d)\r\n" , __FUNCTION__ ,value,dir , str , strlen(str) , sizeof(str));
000038  a803              ADD      r0,sp,#0xc
00003a  f7fffffe          BL       strlen
00003e  aa03              ADD      r2,sp,#0xc
000040  e9cd2000          STRD     r2,r0,[sp,#0]
000044  2120              MOVS     r1,#0x20
000046  9102              STR      r1,[sp,#8]
000048  462b              MOV      r3,r5
00004a  4622              MOV      r2,r4
00004c  4907              LDR      r1,|L4.108|
00004e  a008              ADR      r0,|L4.112|
000050  f7fffffe          BL       __2printf
                  |L4.84|
;;;199    		#endif	
;;;200    	}
;;;201    }
000054  b00b              ADD      sp,sp,#0x2c
000056  bd30              POP      {r4,r5,pc}
;;;202    
                          ENDP

                  |L4.88|
                          DCD      0x400b0000
                  |L4.92|
                          DCD      ||.data||
                  |L4.96|
000060  456e636f          DCB      "Encoder:%d",0
000064  6465723a
000068  256400  
00006b  00                DCB      0
                  |L4.108|
                          DCD      ||.constdata||+0xf
                  |L4.112|
000070  2573203a          DCB      "%s : %5d , 0x%2X (%s , %2d , %2d)\r\n",0
000074  20253564
000078  202c2030
00007c  78253258
000080  20282573
000084  202c2025
000088  3264202c
00008c  20253264
000090  290d0a00

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;365    
;;;366    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L5.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L5.10|
;;;367    {
;;;368        /*---------------------------------------------------------------------------------------------------------*/
;;;369        /* Init System Clock                                                                                       */
;;;370        /*---------------------------------------------------------------------------------------------------------*/
;;;371        /* Unlock protected registers */
;;;372        SYS_UnlockReg();
;;;373    
;;;374        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;375        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2040          MOV      r0,#0x40004000
000022  f8d01140          LDR      r1,[r0,#0x140]
000026  f02101f0          BIC      r1,r1,#0xf0
00002a  f8c01140          STR      r1,[r0,#0x140]
;;;376    
;;;377        /* Enable External XTAL (4~24 MHz) */
;;;378        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk|CLK_PWRCTL_HIRCEN_Msk|CLK_PWRCTL_LIRCEN_Msk);
00002e  200d              MOVS     r0,#0xd
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;379    
;;;380        /* Waiting for 12MHz clock ready */
;;;381        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk|CLK_STATUS_HIRCSTB_Msk|CLK_STATUS_LIRCSTB_Msk);
000034  2019              MOVS     r0,#0x19
000036  f7fffffe          BL       CLK_WaitClockReady
;;;382    
;;;383        /* Set core clock as PLL_CLOCK from PLL */
;;;384        CLK_SetCoreClock(FREQ_192MHZ);
00003a  4829              LDR      r0,|L5.224|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;385        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;386        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;387    
;;;388        /* Enable UART clock */
;;;389        CLK_EnableModuleClock(UART0_MODULE);
000046  4d27              LDR      r5,|L5.228|
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;390        /* Select UART clock source from HXT */
;;;391        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  f04f7140          MOV      r1,#0x3000000
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       CLK_SetModuleClock
;;;392    
;;;393        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;394        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
00005a  6be0              LDR      r0,[r4,#0x3c]
00005c  f420007f          BIC      r0,r0,#0xff0000
000060  63e0              STR      r0,[r4,#0x3c]
;;;395        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000062  6be0              LDR      r0,[r4,#0x3c]
000064  f44000cc          ORR      r0,r0,#0x660000
000068  63e0              STR      r0,[r4,#0x3c]
;;;396    
;;;397    
;;;398        CLK_EnableModuleClock(UART5_MODULE);
00006a  4d1f              LDR      r5,|L5.232|
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       CLK_EnableModuleClock
;;;399        /* Select UART clock source from HXT */
;;;400        CLK_SetModuleClock(UART5_MODULE, CLK_CLKSEL3_UART5SEL_HIRC, CLK_CLKDIV4_UART5(1));
000072  2200              MOVS     r2,#0
000074  f04f4140          MOV      r1,#0xc0000000
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       CLK_SetModuleClock
;;;401    
;;;402        CLK_EnableModuleClock(PDMA_MODULE);
00007e  2001              MOVS     r0,#1
000080  f7fffffe          BL       CLK_EnableModuleClock
;;;403    
;;;404    	CLK_EnableModuleClock(TMR0_MODULE);
000084  4d19              LDR      r5,|L5.236|
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       CLK_EnableModuleClock
;;;405    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0);
00008c  2200              MOVS     r2,#0
00008e  f44f61e0          MOV      r1,#0x700
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       CLK_SetModuleClock
;;;406    	
;;;407        CLK_EnableModuleClock(TMR1_MODULE);
000098  4d15              LDR      r5,|L5.240|
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       CLK_EnableModuleClock
;;;408        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
0000a0  2200              MOVS     r2,#0
0000a2  f44f41e0          MOV      r1,#0x7000
0000a6  4628              MOV      r0,r5
0000a8  f7fffffe          BL       CLK_SetModuleClock
;;;409    
;;;410        CLK_EnableModuleClock(QEI0_MODULE);
0000ac  4811              LDR      r0,|L5.244|
0000ae  f7fffffe          BL       CLK_EnableModuleClock
;;;411    	
;;;412    	
;;;413        /* Update System Core Clock */
;;;414        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;415        SystemCoreClockUpdate();
0000b2  f7fffffe          BL       SystemCoreClockUpdate
;;;416    
;;;417        SYS->GPA_MFPL &= ~(SYS_GPA_MFPL_PA5MFP_Msk  );
0000b6  6b20              LDR      r0,[r4,#0x30]
0000b8  f4200070          BIC      r0,r0,#0xf00000
0000bc  6320              STR      r0,[r4,#0x30]
;;;418        SYS->GPA_MFPL |= (SYS_GPA_MFPL_PA5MFP_UART5_TXD );
0000be  6b20              LDR      r0,[r4,#0x30]
0000c0  f4400000          ORR      r0,r0,#0x800000
0000c4  6320              STR      r0,[r4,#0x30]
;;;419    
;;;420        SYS->GPA_MFPL &= ~(SYS_GPA_MFPL_PA4MFP_Msk | SYS_GPA_MFPL_PA3MFP_Msk );
0000c6  6b20              LDR      r0,[r4,#0x30]
0000c8  f420207f          BIC      r0,r0,#0xff000
0000cc  6320              STR      r0,[r4,#0x30]
;;;421        SYS->GPA_MFPL |= (SYS_GPA_MFPL_PA4MFP_QEI0_A | SYS_GPA_MFPL_PA3MFP_QEI0_B );
0000ce  6b20              LDR      r0,[r4,#0x30]
0000d0  f440206e          ORR      r0,r0,#0xee000
0000d4  6320              STR      r0,[r4,#0x30]
0000d6  2000              MOVS     r0,#0
0000d8  f8c40100          STR      r0,[r4,#0x100]
;;;422    	
;;;423        /* Lock protected registers */
;;;424        SYS_LockReg();
;;;425    }
0000dc  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP

0000de  0000              DCW      0x0000
                  |L5.224|
                          DCD      0x0b71b000
                  |L5.228|
                          DCD      0x57803d10
                  |L5.232|
                          DCD      0x77ec3d95
                  |L5.236|
                          DCD      0x5e800002
                  |L5.240|
                          DCD      0x5ec00003
                  |L5.244|
                          DCD      0x80000016

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;344    
;;;345    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;346    {
;;;347        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L6.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;348        TIMER_EnableInt(TIMER1);
;;;349        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;350        TIMER_Start(TIMER1);
;;;351    }
000028  bd10              POP      {r4,pc}
;;;352    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;320    
;;;321    void TMR1_IRQHandler(void)
000000  480a              LDR      r0,|L7.44|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;322    {
000008  2900              CMP      r1,#0
00000a  d00e              BEQ      |L7.42|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;323    	static uint16_t CNT_1000ms = 0;	
;;;324    //	static uint32_t log = 0;	
;;;325    	
;;;326        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;327        {
;;;328            TIMER_ClearIntFlag(TIMER1);
;;;329    	
;;;330    		if (CNT_1000ms++ > 1000)
000010  4907              LDR      r1,|L7.48|
000012  8808              LDRH     r0,[r1,#0]  ; CNT_1000ms
000014  1c42              ADDS     r2,r0,#1
000016  800a              STRH     r2,[r1,#0]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d905              BLS      |L7.42|
;;;331    		{		
;;;332    			CNT_1000ms = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;333    			#if (_debug_log_UART_ == 1)	//debug			
;;;334    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;335    			#endif		
;;;336    		
;;;337    			set_flag(flag_UART_PDMA , ENABLE);
000022  6848              LDR      r0,[r1,#4]  ; BitFlag
000024  f0400008          ORR      r0,r0,#8
000028  6048              STR      r0,[r1,#4]  ; BitFlag
                  |L7.42|
;;;338    
;;;339    		}
;;;340    		
;;;341        }
;;;342    }
00002a  4770              BX       lr
;;;343    
                          ENDP

                  |L7.44|
                          DCD      0x40050100
                  |L7.48|
                          DCD      ||.data||

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;277    
;;;278    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;279    {
;;;280        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L8.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L8.18|
00000c  e004              B        |L8.24|
                  |L8.14|
;;;281        {
;;;282            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;283            {
;;;284    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L8.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;282
000014  0449              LSLS     r1,r1,#17             ;282
000016  d5fa              BPL      |L8.14|
                  |L8.24|
;;;285            }
;;;286        }
;;;287    
;;;288        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L8.46|
;;;289        {
;;;290            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L8.46|
;;;291        }
;;;292    }
00002e  bd10              POP      {r4,pc}
;;;293    
                          ENDP

                  |L8.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;293    
;;;294    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;295    {
;;;296        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L9.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;297    
;;;298        /* Configure UART0 and set UART0 baud rate */
;;;299        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L9.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;300    
;;;301    	/* Set UART receive time-out */
;;;302    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;303    
;;;304    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;305    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;306    
;;;307    	/* Enable UART Interrupt - */
;;;308    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;309    	
;;;310    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;311    
;;;312    	#if (_debug_log_UART_ == 1)	//debug
;;;313    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a010              ADR      r0,|L9.132|
000044  f7fffffe          BL       __2printf
;;;314    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L9.160|
000050  f7fffffe          BL       __2printf
;;;315    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a017              ADR      r0,|L9.184|
00005c  f7fffffe          BL       __2printf
;;;316    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01a              ADR      r0,|L9.208|
000068  f7fffffe          BL       __2printf
;;;317    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a01d              ADR      r0,|L9.236|
000078  f7ffbffe          B.W      __2printf
;;;318    	#endif
;;;319    }
;;;320    
                          ENDP

                  |L9.124|
                          DCD      0x04000010
                  |L9.128|
                          DCD      0x40070000
                  |L9.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L9.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L9.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L9.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L9.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UART5_Init||, CODE, READONLY, ALIGN=2

                  UART5_Init PROC
;;;272    
;;;273    void UART5_Init(void)
000000  f44f31e1          MOV      r1,#0x1c200
;;;274    {
;;;275        UART_Open(UART_PORT, 115200);
000004  4801              LDR      r0,|L10.12|
000006  f7ffbffe          B.W      UART_Open
;;;276    }
;;;277    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x40075000

                          AREA ||i.UART_TX_PDMA||, CODE, READONLY, ALIGN=2

                  UART_TX_PDMA PROC
;;;128    
;;;129    void UART_TX_PDMA(uint8_t* Datain , uint16_t len)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;130    {
;;;131    	uint32_t u32RegValue = 0;
;;;132    	uint32_t u32Abort = 0;	
;;;133    
;;;134        PDMA_Open(PDMA, UART_TX_PDMA_OPENED_CH);
000004  4e23              LDR      r6,|L11.148|
000006  460c              MOV      r4,r1                 ;130
000008  4607              MOV      r7,r0                 ;130
00000a  f44f6500          MOV      r5,#0x800
00000e  4629              MOV      r1,r5
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       PDMA_Open
;;;135    
;;;136    	//TX
;;;137        PDMA_SetTransferCnt(PDMA,UART_TX_DMA_CH, PDMA_WIDTH_8, len);
000016  4623              MOV      r3,r4
000018  2200              MOVS     r2,#0
00001a  210b              MOVS     r1,#0xb
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       PDMA_SetTransferCnt
;;;138        /* Set source/destination address and attributes */
;;;139        PDMA_SetTransferAddr(PDMA,UART_TX_DMA_CH, (uint32_t) (&Datain[0]), PDMA_SAR_INC, (uint32_t) &UART5->DAT , PDMA_DAR_FIX);//UART5_BASE
000022  f44f6040          MOV      r0,#0xc00
000026  4c1c              LDR      r4,|L11.152|
000028  e9cd4000          STRD     r4,r0,[sp,#0]
00002c  2300              MOVS     r3,#0
00002e  463a              MOV      r2,r7
000030  210b              MOVS     r1,#0xb
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       PDMA_SetTransferAddr
;;;140        /* Set request source; set basic mode. */
;;;141    	
;;;142        PDMA_SetTransferMode(PDMA,UART_TX_DMA_CH, PDMA_UART5_TX, FALSE, 0);
000038  2000              MOVS     r0,#0
00003a  4603              MOV      r3,r0
00003c  9000              STR      r0,[sp,#0]
00003e  220e              MOVS     r2,#0xe
000040  210b              MOVS     r1,#0xb
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       PDMA_SetTransferMode
;;;143    
;;;144        PDMA_SetBurstType(PDMA,UART_TX_DMA_CH, PDMA_REQ_SINGLE, PDMA_BURST_128);
000048  2300              MOVS     r3,#0
00004a  2204              MOVS     r2,#4
00004c  210b              MOVS     r1,#0xb
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       PDMA_SetBurstType
;;;145        /* Disable table interrupt */
;;;146        PDMA->DSCT[UART_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000054  f8560fb0          LDR      r0,[r6,#0xb0]!
000058  f0400080          ORR      r0,r0,#0x80
00005c  6030              STR      r0,[r6,#0]
;;;147    
;;;148    	UART_PDMA_ENABLE(UART5,UART_INTEN_TXPDMAEN_Msk);
00005e  6860              LDR      r0,[r4,#4]
000060  f4404080          ORR      r0,r0,#0x4000
000064  6060              STR      r0,[r4,#4]
;;;149    
;;;150        while(1)
;;;151        {
;;;152            /* Get interrupt status */
;;;153            u32RegValue = PDMA_GET_INT_STATUS(PDMA);
;;;154            /* Check the DMA transfer done interrupt flag */
;;;155            if(u32RegValue & PDMA_INTSTS_TDIF_Msk)
;;;156            {
;;;157                /* Check the PDMA transfer done interrupt flags */
;;;158                if((PDMA_GET_TD_STS(PDMA) & UART_TX_PDMA_OPENED_CH) == UART_TX_PDMA_OPENED_CH)
000066  490d              LDR      r1,|L11.156|
000068  4a0c              LDR      r2,|L11.156|
00006a  3108              ADDS     r1,r1,#8
                  |L11.108|
00006c  6810              LDR      r0,[r2,#0]            ;153
00006e  0783              LSLS     r3,r0,#30             ;155
000070  d509              BPL      |L11.134|
000072  680b              LDR      r3,[r1,#0]
000074  051b              LSLS     r3,r3,#20
000076  d506              BPL      |L11.134|
;;;159                {
;;;160                    /* Clear the DMA transfer done flags */
;;;161                    PDMA_CLR_TD_FLAG(PDMA , UART_TX_PDMA_OPENED_CH);
000078  600d              STR      r5,[r1,#0]
;;;162    				UART_PDMA_DISABLE(UART5,UART_INTEN_TXPDMAEN_Msk);				
00007a  6860              LDR      r0,[r4,#4]
00007c  f4204080          BIC      r0,r0,#0x4000
000080  6060              STR      r0,[r4,#4]
                  |L11.130|
;;;163                    break;
;;;164                }
;;;165            }
;;;166            /* Check the DMA transfer abort interrupt flag */
;;;167            if(u32RegValue & PDMA_INTSTS_ABTIF_Msk)
;;;168            {
;;;169                /* Get the target abort flag */
;;;170                u32Abort = PDMA_GET_ABORT_STS(PDMA);
;;;171                /* Clear the target abort flag */
;;;172                PDMA_CLR_ABORT_FLAG(PDMA,u32Abort);
;;;173                break;
;;;174            }		
;;;175        }
;;;176    }
000082  e8bd81fc          POP      {r2-r8,pc}
                  |L11.134|
000086  07c0              LSLS     r0,r0,#31             ;167
000088  d0f0              BEQ      |L11.108|
00008a  4904              LDR      r1,|L11.156|
00008c  1d09              ADDS     r1,r1,#4              ;170
00008e  6808              LDR      r0,[r1,#0]            ;170
000090  6008              STR      r0,[r1,#0]            ;172
000092  e7f6              B        |L11.130|
;;;177    
                          ENDP

                  |L11.148|
                          DCD      0x40008000
                  |L11.152|
                          DCD      0x40075000
                  |L11.156|
                          DCD      0x4000841c

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;241    
;;;242    void UARTx_Process(void)
000000  4810              LDR      r0,|L12.68|
;;;243    {
;;;244    	uint8_t res = 0;
;;;245    
;;;246    	res = UART_READ(UART0);
000002  6800              LDR      r0,[r0,#0]
000004  b2c0              UXTB     r0,r0
;;;247    
;;;248    	if (res > 0x7F)
000006  287f              CMP      r0,#0x7f
000008  d902              BLS      |L12.16|
;;;249    	{
;;;250    		printf("invalid command\r\n");
00000a  a00f              ADR      r0,|L12.72|
00000c  f7ffbffe          B.W      __2printf
                  |L12.16|
;;;251    	}
;;;252    	else
;;;253    	{
;;;254    		switch(res)
000010  285a              CMP      r0,#0x5a
000012  d009              BEQ      |L12.40|
000014  dc04              BGT      |L12.32|
000016  2831              CMP      r0,#0x31
000018  d013              BEQ      |L12.66|
00001a  2858              CMP      r0,#0x58
00001c  d111              BNE      |L12.66|
00001e  e003              B        |L12.40|
                  |L12.32|
000020  2878              CMP      r0,#0x78
000022  d001              BEQ      |L12.40|
000024  287a              CMP      r0,#0x7a
000026  d10c              BNE      |L12.66|
                  |L12.40|
000028  f3bf8f4f          DSB      
00002c  480b              LDR      r0,|L12.92|
00002e  6801              LDR      r1,[r0,#0]
000030  4a0b              LDR      r2,|L12.96|
000032  f40161e0          AND      r1,r1,#0x700
000036  4311              ORRS     r1,r1,r2
000038  6001              STR      r1,[r0,#0]
00003a  f3bf8f4f          DSB      
                  |L12.62|
00003e  bf00              NOP      
000040  e7fd              B        |L12.62|
                  |L12.66|
;;;255    		{
;;;256    	
;;;257    			case '1':
;;;258    
;;;259    				break;	
;;;260    
;;;261    			case 'X':
;;;262    			case 'x':
;;;263    			case 'Z':
;;;264    			case 'z':
;;;265    				NVIC_SystemReset();
;;;266    			
;;;267    				break;		
;;;268    			
;;;269    		}
;;;270    	}
;;;271    }
000042  4770              BX       lr
;;;272    
                          ENDP

                  |L12.68|
                          DCD      0x40070000
                  |L12.72|
000048  696e7661          DCB      "invalid command\r\n",0
00004c  6c696420
000050  636f6d6d
000054  616e640d
000058  0a00    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L12.92|
                          DCD      0xe000ed0c
                  |L12.96|
                          DCD      0x05fa0004

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;31     /*_____ F U N C T I O N S ______------______________________________________*/
;;;32     void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;33     {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4680              MOV      r8,r0
;;;34         uint16_t i = 0;	
00000a  2400              MOVS     r4,#0
;;;35     	
;;;36         for (i = 0; i < nBytes; i++)
;;;37         {
;;;38             if (src[i] != des[i])
;;;39             {
;;;40     			#if (_debug_log_UART_ == 1)	//debug
;;;41                 printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
;;;42     			#endif
;;;43     			set_flag(flag_compare_error , ENABLE);
00000c  4d0f              LDR      r5,|L13.76|
00000e  e00e              B        |L13.46|
                  |L13.16|
000010  f8182004          LDRB     r2,[r8,r4]            ;38
000014  5d3b              LDRB     r3,[r7,r4]            ;38
000016  429a              CMP      r2,r3                 ;38
000018  d007              BEQ      |L13.42|
00001a  4621              MOV      r1,r4                 ;41
00001c  a00c              ADR      r0,|L13.80|
00001e  f7fffffe          BL       __2printf
000022  6868              LDR      r0,[r5,#4]  ; BitFlag
000024  f0400002          ORR      r0,r0,#2
000028  6068              STR      r0,[r5,#4]  ; BitFlag
                  |L13.42|
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4                 ;36
                  |L13.46|
00002e  42b4              CMP      r4,r6                 ;36
000030  dbee              BLT      |L13.16|
;;;44             }
;;;45         }
;;;46     
;;;47     	if (!is_flag_set(flag_compare_error))
000032  6868              LDR      r0,[r5,#4]  ; BitFlag
000034  0780              LSLS     r0,r0,#30
000036  d407              BMI      |L13.72|
;;;48     	{
;;;49     		#if (_debug_log_UART_ == 1)	//debug
;;;50         	printf("%s finish \r\n" , __FUNCTION__);	
000038  490e              LDR      r1,|L13.116|
00003a  a00f              ADR      r0,|L13.120|
00003c  f7fffffe          BL       __2printf
;;;51     		#endif
;;;52     		set_flag(flag_compare_error , DISABLE);
000040  6868              LDR      r0,[r5,#4]  ; BitFlag
000042  f0200002          BIC      r0,r0,#2
000046  6068              STR      r0,[r5,#4]  ; BitFlag
                  |L13.72|
;;;53     	}
;;;54     
;;;55     }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;56     
                          ENDP

                  |L13.76|
                          DCD      ||.data||
                  |L13.80|
000050  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
000054  72206964
000058  78203a20
00005c  25346420
000060  3a203078
000064  25325820
000068  2c203078
00006c  2532580d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L13.116|
                          DCD      ||.constdata||
                  |L13.120|
000078  25732066          DCB      "%s finish \r\n",0
00007c  696e6973
000080  68200d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.copy_buffer||, CODE, READONLY, ALIGN=1

                  copy_buffer PROC
;;;110    
;;;111    void copy_buffer(void *dest, void *src, unsigned int size)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113        uint8_t *pu8Src, *pu8Dest;
;;;114        unsigned int i;
;;;115        
;;;116        pu8Dest = (uint8_t *)dest;
;;;117        pu8Src  = (uint8_t *)src;
;;;118    
;;;119    
;;;120    	#if 0
;;;121    	  while (size--)
;;;122    	    *pu8Dest++ = *pu8Src++;
;;;123    	#else
;;;124        for (i = 0; i < size; i++)
000002  2300              MOVS     r3,#0
000004  e002              B        |L14.12|
                  |L14.6|
;;;125            pu8Dest[i] = pu8Src[i];
000006  5ccc              LDRB     r4,[r1,r3]
000008  54c4              STRB     r4,[r0,r3]
00000a  1c5b              ADDS     r3,r3,#1
                  |L14.12|
00000c  4293              CMP      r3,r2                 ;124
00000e  d3fa              BCC      |L14.6|
;;;126    	#endif
;;;127    }
000010  bd10              POP      {r4,pc}
;;;128    
                          ENDP


                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;69     
;;;70     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;71     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;72         uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;73         
;;;74         printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L15.56|
00000a  f7fffffe          BL       __2printf
;;;75         for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L15.42|
                  |L15.16|
;;;76         {
;;;77             printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L15.76|
000014  f7fffffe          BL       __2printf
;;;78             if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L15.38|
;;;79             {
;;;80                 printf("\r\n");
000020  a00c              ADR      r0,|L15.84|
000022  f7fffffe          BL       __2printf
                  |L15.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;75
                  |L15.42|
00002a  42ac              CMP      r4,r5                 ;75
00002c  dbf0              BLT      |L15.16|
;;;81             }            
;;;82         }
;;;83         printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L15.88|
000034  f7ffbffe          B.W      __2printf
;;;84     }
;;;85     
                          ENDP

                  |L15.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L15.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L15.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L15.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;85     
;;;86     void  dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;87     {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;88         int     nIdx, i;
;;;89     
;;;90         nIdx = 0;
000008  2500              MOVS     r5,#0
00000a  e025              B        |L16.88|
                  |L16.12|
;;;91         while (nBytes > 0)
;;;92         {
;;;93             printf("0x%04X  ", nIdx);
00000c  4629              MOV      r1,r5
00000e  a016              ADR      r0,|L16.104|
000010  f7fffffe          BL       __2printf
;;;94             for (i = 0; i < 16; i++)
000014  2400              MOVS     r4,#0
                  |L16.22|
;;;95                 printf("%02X ", pucBuff[nIdx + i]);
000016  1928              ADDS     r0,r5,r4
000018  5c39              LDRB     r1,[r7,r0]
00001a  a016              ADR      r0,|L16.116|
00001c  f7fffffe          BL       __2printf
000020  1c64              ADDS     r4,r4,#1
000022  2c10              CMP      r4,#0x10              ;94
000024  dbf7              BLT      |L16.22|
;;;96             printf("  ");
000026  a015              ADR      r0,|L16.124|
000028  f7fffffe          BL       __2printf
;;;97             for (i = 0; i < 16; i++)
00002c  2400              MOVS     r4,#0
                  |L16.46|
;;;98             {
;;;99                 if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002e  1928              ADDS     r0,r5,r4
000030  5c39              LDRB     r1,[r7,r0]
000032  f1a10020          SUB      r0,r1,#0x20
000036  285f              CMP      r0,#0x5f
000038  d203              BCS      |L16.66|
;;;100                    printf("%c", pucBuff[nIdx + i]);
00003a  a011              ADR      r0,|L16.128|
00003c  f7fffffe          BL       __2printf
000040  e002              B        |L16.72|
                  |L16.66|
;;;101                else
;;;102                    printf(".");
000042  a010              ADR      r0,|L16.132|
000044  f7fffffe          BL       __2printf
                  |L16.72|
000048  1c64              ADDS     r4,r4,#1
00004a  1e76              SUBS     r6,r6,#1
00004c  2c10              CMP      r4,#0x10              ;97
00004e  dbee              BLT      |L16.46|
;;;103                nBytes--;
;;;104            }
;;;105            nIdx += 16;
;;;106            printf("\n");
000050  a00d              ADR      r0,|L16.136|
000052  3510              ADDS     r5,r5,#0x10
000054  f7fffffe          BL       __2printf
                  |L16.88|
000058  2e00              CMP      r6,#0                 ;91
00005a  dcd7              BGT      |L16.12|
;;;107        }
;;;108        printf("\n");
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  a009              ADR      r0,|L16.136|
000062  f7ffbffe          B.W      __2printf
;;;109    }
;;;110    
                          ENDP

000066  0000              DCW      0x0000
                  |L16.104|
000068  30782530          DCB      "0x%04X  ",0
00006c  34582020
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L16.116|
000074  25303258          DCB      "%02X ",0
000078  2000    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L16.124|
00007c  202000            DCB      "  ",0
00007f  00                DCB      0
                  |L16.128|
000080  256300            DCB      "%c",0
000083  00                DCB      0
                  |L16.132|
000084  2e00              DCB      ".",0
000086  00                DCB      0
000087  00                DCB      0
                  |L16.136|
000088  0a00              DCB      "\n",0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;434    
;;;435    int main()
000000  f7fffffe          BL       SYS_Init
;;;436    {	
;;;437        SYS_Init();
;;;438    
;;;439    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;440    	Custom_Init();	
000008  f7fffffe          BL       Custom_Init
;;;441    
;;;442    	UART5_Init();
00000c  f7fffffe          BL       UART5_Init
;;;443    
;;;444    	TIMER1_Init();
000010  f7fffffe          BL       TIMER1_Init
;;;445    
;;;446    //    NVIC_EnableIRQ(PDMA_IRQn);
;;;447    
;;;448    	QEI0_Init();
000014  f7fffffe          BL       QEI0_Init
                  |L17.24|
;;;449    
;;;450        /* Got no where to go, just loop forever */
;;;451        while(1)
;;;452        {
;;;453    		QEI0_Process();
000018  f7fffffe          BL       QEI0_Process
00001c  e7fc              B        |L17.24|
;;;454    
;;;455        }
;;;456    }
;;;457    
                          ENDP


                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;56     
;;;57     void reset_buffer(uint8_t *pucBuff, int nBytes)
000000  2200              MOVS     r2,#0
;;;58     {
;;;59     	#if 1
;;;60         uint16_t i = 0;	
000002  4613              MOV      r3,r2
000004  e002              B        |L18.12|
                  |L18.6|
;;;61         for ( i = 0; i < nBytes; i++)
;;;62         {
;;;63             pucBuff[i] = 0x00;
000006  5483              STRB     r3,[r0,r2]
000008  1c52              ADDS     r2,r2,#1
00000a  b292              UXTH     r2,r2                 ;61
                  |L18.12|
00000c  428a              CMP      r2,r1                 ;61
00000e  dbfa              BLT      |L18.6|
;;;64         }	
;;;65     	#else	//extra 20 bytes , with <string.h>
;;;66     	memset(pucBuff, 0, nBytes * (sizeof(pucBuff[0]) ));
;;;67     	#endif
;;;68     }
000010  4770              BX       lr
;;;69     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000004  6172655f          DCB      0x61,0x72,0x65,0x5f
000008  62756666          DCB      0x62,0x75,0x66,0x66
00000c  657200            DCB      0x65,0x72,0x00
                  |symbol_number.56|
00000f  51                DCB      0x51
000010  4549305f          DCB      0x45,0x49,0x30,0x5f
000014  50726f63          DCB      0x50,0x72,0x6f,0x63
000018  65737300          DCB      0x65,0x73,0x73,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  CNT_1000ms
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  BitFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
